import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import Resources;
import TwoCansAlpha4;

const X_RES = $var["screen_width"];
const Y_RES = $var["screen_height"];

const FLASH_DURATION = 48;

// The number of vowels to include in the tray.
const N_VOWELS = 5;
// The number of consonants to include in the tray.
const N_CONSONANTS = 7;

// The proportion of possible words required to be found in order to win.
const REQUIRED_SCORE_RATIO = 0.25;

const SIDE_MARGIN = 0.5 * 10.0;

const BOARD_FONT_SIZE = 18;
const BOARD_ROW_HEIGHT = 32.0;
const BOARD_COL_WIDTH = 21.0;
const BOARD_N_COLS = floor((X_RES - 2.0 * SIDE_MARGIN) / BOARD_COL_WIDTH);
const BOARD_MIN_ROWS = 12;
const BOARD_MAX_ROWS = 14;
const BOARD_TOP_MARGIN = 3.5 * BOARD_ROW_HEIGHT;
const SCORE_BAR_HEIGHT = 20;

const BUTTON_MARGIN_TOP = 10.0;
const BUTTON_MARGIN_BETWEEN = 10.0;

const TRAY_FONT_SIZE = 24;
const TRAY_X = 305.0;
const TRAY_Y = 8.0;
const TRAY_HEIGHT = 40.0;
const TRAY_COL_WIDTH = 27.0;

const GUESS_X = TRAY_X;
const GUESS_Y = 62.0;
const GUESS_HEIGHT = 30.0;
const GUESS_COL_WIDTH = BOARD_COL_WIDTH;

enum TextColor { BLACK, GREEN, YELLOW, RED }

function stringToCharCounts(string) {
	result = {};
	for (c : string) {
		if (!result.contains(c)) {
			result[c] = 0;
		}
		++result[c];
	}
	return result;
}

function lengthThreeOrMore(string) { return string.length >= 3; }
function getLength(list) { return list.length; }

class MainScene : AbstractScene {
	static field vowels = ["A", "E", "I", "O", "U"];
	static field consonants =
		[ "B", "C", "D", "F", "G", "H", "J"
		, "K", "L", "M", "N", "P", "Q", "R"
		, "S", "T", "V", "W", "X", "Y", "Z"
		];
	static field alphabet =
		[ "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M"
		, "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"
		];
	static field keys;
	static field letterToKey;
	static field keyToLetter;

	static field scoreMap =
		{ "A": 1, "E": 1, "I": 1, "O": 1, "U": 1, "L": 1, "N": 1, "S": 1, "T": 1, "R": 1
		, "D": 2, "G": 2
		, "B": 3, "C": 3, "M": 3, "P": 3
		, "F": 4, "H": 4, "V": 4, "W": 4, "Y": 4
		, "K": 5
		, "J": 8, "X": 8
		, "Q": 10, "Z": 10
		};
	static function getScore(word) {
		result = 0;
		for (c : word) {
			result += MainScene.scoreMap[c];
		}
		return result;
	}

	static constructor() {
		// Create key list.
		MainScene.keys =
			[ KeyboardKey.A
			, KeyboardKey.B
			, KeyboardKey.C
			, KeyboardKey.D
			, KeyboardKey.E
			, KeyboardKey.F
			, KeyboardKey.G
			, KeyboardKey.H
			, KeyboardKey.I
			, KeyboardKey.J
			, KeyboardKey.K
			, KeyboardKey.L
			, KeyboardKey.M
			, KeyboardKey.N
			, KeyboardKey.O
			, KeyboardKey.P
			, KeyboardKey.Q
			, KeyboardKey.R
			, KeyboardKey.S
			, KeyboardKey.T
			, KeyboardKey.U
			, KeyboardKey.V
			, KeyboardKey.W
			, KeyboardKey.X
			, KeyboardKey.Y
			, KeyboardKey.Z
			];
		// Create letter-to-key map.
		MainScene.letterToKey = {};
		MainScene.keyToLetter = {};
		for (i = 0; i < MainScene.keys.length; ++i) {
			MainScene.letterToKey[MainScene.alphabet[i]] = MainScene.keys[i];
			MainScene.keyToLetter[MainScene.keys[i]] = MainScene.alphabet[i];
		}
	}

	field words;
	field foundWordMap;

	field maxLength;
	field tray;
	field guess;
	field currentScore;
	field maxScore;

	field trayLetterToImage = {};
	field boardLetterToImage = {};

	field flashTimer;
	field flashColor;
	field flashWordSet;
	field missedWordSet;

	field buttons;
	field checkButton;
	field shuffleButton;
	field clearButton;
	field deleteButton;
	field concedeRestartButton;

	function reset() {
		this.guess = "";
		this.flashTimer = 0;
		this.flashWordSet = {};
		this.missedWordSet = {};

		// Add random letters to the tray.
		this.tray = [];
		for (i = 0; i < N_VOWELS; ++i) {
			this.tray.add(MainScene.vowels.choice());
		}
		for (i = 0; i < N_CONSONANTS; ++i) {
			this.tray.add(MainScene.consonants.choice());
		}
		this.tray.shuffle();

		// Find possible words with at least three letters.
		possibleWords = this.words
			.getWordsUsing(stringToCharCounts(this.tray));
		// Ensure there's at least one valid word.
		if (possibleWords.length == 0) {
			this.reset();
			return;
		}
		// Shuffle and then sort by length, to avoid giving hints besides word length.
		possibleWords.shuffle();
		possibleWords.sort(getLength);
		// Populate the found word map and find the max word length and max score.
		this.foundWordMap = {};
		this.maxLength = 0;
		this.currentScore = 0;
		this.maxScore = 0;
		for (word : possibleWords) {
			this.foundWordMap[word] = false;
			this.maxScore += MainScene.getScore(word);
			if (word.length > this.maxLength) {
				this.maxLength = word.length;
			}
		}

		// Ensure that the number of rows is within the desired range.
		row = 0;
		col = 0;
		for (word : this.foundWordMap.keys()) {
			if (col + word.length >= BOARD_N_COLS) {
				++row;
				col = 0;
			}
			col += word.length + 1;
		}
		nrows = row + 1;
		if (nrows < BOARD_MIN_ROWS || nrows > BOARD_MAX_ROWS) {
			this.reset();
		}

		// Set concede/restart button text to concede.
		this.concedeRestartButton.setText("Concede (Esc)");
	}

	constructor(words) {
		this.words = words;

		font = FontResource.fromResource("Courier Prime.ttf").getRenderer();
		// Render tray letters.
		font.setSize(TRAY_FONT_SIZE).setStyle(FontStyle.BOLD);
		for (letter : MainScene.alphabet + ["-"]) {
			entry = {};
			font.setColor(0, 0, 0);
			entry[TextColor.BLACK] = font.render(letter);
			font.setColor(0, 192, 0);
			entry[TextColor.GREEN] = font.render(letter);
			font.setColor(255, 192, 0);
			entry[TextColor.YELLOW] = font.render(letter);
			font.setColor(255, 0, 0);
			entry[TextColor.RED] = font.render(letter);
			this.trayLetterToImage[letter] = entry;
		}

		// Render board letters.
		font.setSize(BOARD_FONT_SIZE).setStyle(FontStyle.NORMAL);
		for (letter : MainScene.alphabet + ["-"]) {
			entry = {};
			font.setColor(0, 0, 0);
			entry[TextColor.BLACK] = font.render(letter);
			font.setColor(0, 192, 0);
			entry[TextColor.GREEN] = font.render(letter);
			font.setColor(255, 192, 0);
			entry[TextColor.YELLOW] = font.render(letter);
			font.setColor(255, 0, 0);
			entry[TextColor.RED] = font.render(letter);
			this.boardLetterToImage[letter] = entry;
		}

		// Add buttons.
		this.buttons = [];
		x = SIDE_MARGIN;
		// Clear
		this.clearButton = new Button(x, BUTTON_MARGIN_TOP, 0.0, 0.0, "Clear (Space)");
		this.clearButton.hotkeys.add(KeyboardKey.SPACE);
		this.buttons.add(this.clearButton);
		x += this.clearButton.width + SIDE_MARGIN;
		// Delete
		this.deleteButton = new Button(x, BUTTON_MARGIN_TOP, 0.0, 0.0, "Delete (. / ‚Üê)");
		this.deleteButton.hotkeys.add(KeyboardKey.PERIOD);
		this.deleteButton.hotkeys.add(KeyboardKey.LEFT);
		this.buttons.add(this.deleteButton);
		// Shuffle
		x = SIDE_MARGIN;
		y = BUTTON_MARGIN_TOP + BUTTON_MARGIN_BETWEEN + BUTTON_HEIGHT;
		this.shuffleButton = new Button(x, y, 0.0, 0.0, "Shuffle (Shift)");
		this.shuffleButton.repeatable = true;
		this.buttons.add(this.shuffleButton);
		x += this.shuffleButton.width + SIDE_MARGIN;
		// Check
		this.checkButton = new Button(x, y, 0.0, 0.0, "Check (Enter)");
		this.checkButton.hotkeys.add(KeyboardKey.ENTER);
		this.buttons.add(this.checkButton);
		// Concede/restart
		this.concedeRestartButton = new Button(X_RES - SIDE_MARGIN, BUTTON_MARGIN_TOP, 1.0, 0.0, " ");
		this.concedeRestartButton.hotkeys.add(KeyboardKey.ESCAPE);
		this.buttons.add(this.concedeRestartButton);

		this.reset();
	}

	function emptyTray() {
		for (letter : this.guess) {
			this.tray.add(letter);
		}
		this.guess = "";
	}

	function revealAll() {
		revealedAny = false;
		this.flashWordSet = {};
		for (word : this.foundWordMap.keys()) {
			if (!this.foundWordMap[word]) {
				this.foundWordMap[word] = true;
				this.missedWordSet[word] = true;
				revealedAny = true;
			}
		}
		if (revealedAny) {
			this.flashColor = this.currentScore < floor(REQUIRED_SCORE_RATIO * this.maxScore)
				? TextColor.RED
				: TextColor.GREEN
				;
		}
		this.changeConcedeButtonToRestart();
		return revealedAny;
	}

	function changeConcedeButtonToRestart() {
		this.concedeRestartButton.setText("Restart (Esc)");
	}

	function update(inputManager, events) {
		// Update buttons.
		for (element : this.buttons) {
			element.update(inputManager, events);
		}

		// Reveal all or reset.
		if (this.concedeRestartButton.clicked) {
			if (!this.revealAll()) {
				this.reset();
			}
		}

		// Shuffle letter tray.
		if (this.shuffleButton.clicked || inputManager.isShiftPressed()) {
			this.tray.shuffle();
		}

		// Use letters from tray.
		for (event : events) {
			if (event.type == EventType.KEY && event.down) {
				if (MainScene.keyToLetter.contains(event.key)) {
					letter = MainScene.keyToLetter[event.key];
					for (i = 0; i < this.tray.length; ++i) {
						if (this.tray[i] == letter) {
							this.guess += this.tray[i];
							this.tray.remove(i);
							break;
						}
					}
				}
			}
		}
		// Check for clicked tray letters.
		for (i = 0; i < this.tray.length; ++i) {
			if (inputManager.didMouseClickHere(TRAY_X + i * TRAY_COL_WIDTH, TRAY_Y, TRAY_COL_WIDTH, TRAY_HEIGHT)) {
				this.guess += this.tray[i];
				this.tray.remove(i);
				break;
			}
		}

		// Return letters to tray.
		if (this.clearButton.clicked) {
			this.emptyTray();
		}

		// Return one letter to tray.
		if (this.deleteButton.clicked) {
			if (this.guess.length > 0) {
				this.tray.add(this.guess[-1]);
				this.guess = this.guess[:-1];
			}
		}
		// Check for clicked guess letters.
		for (i = 0; i < this.guess.length; ++i) {
			if (inputManager.didMouseClickHere(GUESS_X + i * GUESS_COL_WIDTH, GUESS_Y, GUESS_COL_WIDTH, GUESS_HEIGHT)) {
				this.tray.add(this.guess[i]);
				this.guess = this.guess[:i] + this.guess[i+1:];
				break;
			}
		}

		// Check current guess.
		if (this.checkButton.clicked) {
			this.flashTimer = FLASH_DURATION;
			this.flashWordSet = {};
			this.flashWordSet[this.guess] = true;
			if (this.foundWordMap.contains(this.guess)) {
				if (this.foundWordMap[this.guess]) {
					// Already found this word.
					this.flashColor = TextColor.YELLOW;
				} else {
					// New word.
					this.currentScore += MainScene.getScore(this.guess);
					this.flashColor = TextColor.GREEN;
					this.foundWordMap[this.guess] = true;
					// Change the concede button to "reveal" if enough words have been found.
					if (this.currentScore >= floor(REQUIRED_SCORE_RATIO * this.maxScore)) {
						this.concedeRestartButton.setText("Reveal All (Esc)");
						// Change the concede button to "restart" if all words have been found.
						foundAll = true;
						for (word : this.foundWordMap.keys()) {
							if (!this.foundWordMap[word]) {
								foundAll = false;
								break;
							}
						}
						if (foundAll) {
							this.concedeRestartButton.setText("Restart (Esc)");
						}
					}
				}
				this.emptyTray();
			} else {
				this.flashColor = TextColor.RED;
			}
		}

		if (this.flashTimer > 0) {
			--this.flashTimer;
		}
	}

	function drawWord(string, x, y, traySized) {
		if (this.missedWordSet.contains(string)) {
			color = this.flashColor;
		} else {
			color = this.flashTimer % 12 >= 6 && this.flashWordSet.contains(string)
				? this.flashColor
				: TextColor.BLACK
				;
		}
		for (letter : string) {
			image = traySized ? this.trayLetterToImage[letter][color] : this.boardLetterToImage[letter][color];
			image.draw(x, y);
			x += traySized ? TRAY_COL_WIDTH : BOARD_COL_WIDTH;
		}
	}

	function render() {
		Graphics2D.Draw.fill(255, 255, 255);

		// Draw tray letters.
		this.drawWord(this.tray.join(""), TRAY_X, TRAY_Y, true);

		// Draw current guess.
		this.drawWord(this.guess, GUESS_X, GUESS_Y, false);

		// Draw found and missing words.
		row = 0;
		col = 0;
		for (word : this.foundWordMap.keys()) {
			if (col + word.length >= BOARD_N_COLS) {
				++row;
				col = 0;
			}
			this.drawWord
				( this.foundWordMap[word] ? word : "-" * word.length
				, col * BOARD_COL_WIDTH + SIDE_MARGIN
				, row * BOARD_ROW_HEIGHT + BOARD_TOP_MARGIN
				, false
				);
			col += word.length + 1;
		}

		// Draw buttons.
		for (element : this.buttons) {
			element.draw();
		}

		// Draw score bar.
		Graphics2D.Draw.rectangle
			( 0
			, Y_RES - SCORE_BAR_HEIGHT
			, X_RES
			, SCORE_BAR_HEIGHT
			, 0, 0, 0
			);
		if (this.currentScore >= REQUIRED_SCORE_RATIO * this.maxScore) {
			r = 0;
			g = 255;
		} else {
			r = 255;
			g = 0;
		}
		Graphics2D.Draw.rectangle
			( 1
			, Y_RES - SCORE_BAR_HEIGHT + 1
			, (X_RES - 2) * this.currentScore / this.maxScore
			, SCORE_BAR_HEIGHT - 2
			, r, g, 0
			);
		Graphics2D.Draw.line(X_RES / 4, Y_RES - SCORE_BAR_HEIGHT + 1, X_RES / 4, Y_RES - 1, 2, 0, 255, 0);
	}
}
