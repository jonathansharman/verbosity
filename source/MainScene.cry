import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import Resources;
import TwoCansAlpha4;

const X_RES = $var["screen_width"];
const Y_RES = $var["screen_height"];

const FLASH_DURATION = 48;

// The number of vowels to include in the tray.
const N_VOWELS = 5;
// The number of consonants to include in the tray.
const N_CONSONANTS = 7;

// The proportion of possible words required to be found in order to win.
const REQUIRED_SCORE_RATIO = 0.25;

const TRAY_FONT_SIZE = 24;
const BOARD_FONT_SIZE = 18;
const ROW_HEIGHT = 32.0;
const TRAY_COL_WIDTH = 27.0;
const BOARD_COL_WIDTH = 21.0;
const N_COLS = floor((X_RES - 2.0 * SIDE_PADDING) / BOARD_COL_WIDTH);
const MIN_ROWS = 12;
const MAX_ROWS = 14;
const BOARD_TOP_PADDING = 3.5 * ROW_HEIGHT;
const SIDE_PADDING = 0.5 * BOARD_COL_WIDTH;
const SCORE_BAR_HEIGHT = 20;

enum TextColor { BLACK, GREEN, YELLOW, RED }

function stringToCharCounts(string) {
	result = {};
	for (c : string) {
		if (!result.contains(c)) {
			result[c] = 0;
		}
		++result[c];
	}
	return result;
}

function lengthThreeOrMore(string) { return string.length >= 3; }
function getLength(list) { return list.length; }

class MainScene : AbstractScene {
	static field vowels = ["A", "E", "I", "O", "U"];
	static field consonants = ["B", "C", "D", "F", "G", "H", "J", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "X", "Y", "Z"];
	static field alphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
	static field keys;
	static field letterToKey;
	static field keyToLetter;

	static field scoreMap =
		{ "A": 1, "E": 1, "I": 1, "O": 1, "U": 1, "L": 1, "N": 1, "S": 1, "T": 1, "R": 1
		, "D": 2, "G": 2
		, "B": 3, "C": 3, "M": 3, "P": 3
		, "F": 4, "H": 4, "V": 4, "W": 4, "Y": 4
		, "K": 5
		, "J": 8, "X": 8
		, "Q": 10, "Z": 10
		};
	static function getScore(word) {
		result = 0;
		for (c : word) {
			result += MainScene.scoreMap[c];
		}
		return result;
	}

	static constructor() {
		// Create key list.
		MainScene.keys =
			[ KeyboardKey.A
			, KeyboardKey.B
			, KeyboardKey.C
			, KeyboardKey.D
			, KeyboardKey.E
			, KeyboardKey.F
			, KeyboardKey.G
			, KeyboardKey.H
			, KeyboardKey.I
			, KeyboardKey.J
			, KeyboardKey.K
			, KeyboardKey.L
			, KeyboardKey.M
			, KeyboardKey.N
			, KeyboardKey.O
			, KeyboardKey.P
			, KeyboardKey.Q
			, KeyboardKey.R
			, KeyboardKey.S
			, KeyboardKey.T
			, KeyboardKey.U
			, KeyboardKey.V
			, KeyboardKey.W
			, KeyboardKey.X
			, KeyboardKey.Y
			, KeyboardKey.Z
			];
		// Create letter-to-key map.
		MainScene.letterToKey = {};
		MainScene.keyToLetter = {};
		for (i = 0; i < MainScene.keys.length; ++i) {
			MainScene.letterToKey[MainScene.alphabet[i]] = MainScene.keys[i];
			MainScene.keyToLetter[MainScene.keys[i]] = MainScene.alphabet[i];
		}
	}

	field words;
	field foundWordMap;

	field maxLength;
	field current;
	field letters;
	field currentScore;
	field maxScore;

	field trayLetterToImage = {};
	field boardLetterToImage = {};

	field flashTimer;
	field flashColor;
	field flashWordSet;
	field missedWordSet;

	function reset() {
		this.current = "";
		this.flashTimer = 0;
		this.flashWordSet = {};
		this.missedWordSet = {};

		// Add random letters.
		this.letters = [];
		for (i = 0; i < N_VOWELS; ++i) {
			this.letters.add(MainScene.vowels.choice());
		}
		for (i = 0; i < N_CONSONANTS; ++i) {
			this.letters.add(MainScene.consonants.choice());
		}
		this.letters.shuffle();

		// Find possible words with at least three letters.
		possibleWords = this.words
			.getWordsUsing(stringToCharCounts(this.letters))
			.filter(word => word.length >= 3);
		// Ensure there's at least one valid word.
		if (possibleWords.length == 0) {
			this.reset();
			return;
		}
		// Shuffle and then sort by length, to avoid giving hints besides word length.
		possibleWords.shuffle();
		possibleWords.sort(getLength);
		// Populate the found word map and find the max word length and max score.
		this.foundWordMap = {};
		this.maxLength = 0;
		this.currentScore = 0;
		this.maxScore = 0;
		for (word : possibleWords) {
			this.foundWordMap[word] = false;
			this.maxScore += MainScene.getScore(word);
			if (word.length > this.maxLength) {
				this.maxLength = word.length;
			}
		}

		// Ensure that the number of rows is within the desired range.
		row = 0;
		col = 0;
		for (word : this.foundWordMap.keys()) {
			if (col + word.length >= N_COLS) {
				++row;
				col = 0;
			}
			col += word.length + 1;
		}
		nrows = row + 1;
		if (nrows < MIN_ROWS || nrows > MAX_ROWS) {
			this.reset();
		}
	}

	constructor(words) {
		this.words = words;

		// Render tray letters.
		font = FontResource.fromResource("Courier Prime.ttf").getRenderer().setSize(TRAY_FONT_SIZE);
		for (letter : MainScene.alphabet + ["-"]) {
			entry = {};
			font.setColor(0, 0, 0);
			entry[TextColor.BLACK] = font.render(letter);
			font.setColor(0, 192, 0);
			entry[TextColor.GREEN] = font.render(letter);
			font.setColor(255, 192, 0);
			entry[TextColor.YELLOW] = font.render(letter);
			font.setColor(255, 0, 0);
			entry[TextColor.RED] = font.render(letter);
			this.trayLetterToImage[letter] = entry;
		}
		// Render board letters.
		font.setSize(BOARD_FONT_SIZE);
		for (letter : MainScene.alphabet + ["-"]) {
			entry = {};
			font.setColor(0, 0, 0);
			entry[TextColor.BLACK] = font.render(letter);
			font.setColor(0, 192, 0);
			entry[TextColor.GREEN] = font.render(letter);
			font.setColor(255, 192, 0);
			entry[TextColor.YELLOW] = font.render(letter);
			font.setColor(255, 0, 0);
			entry[TextColor.RED] = font.render(letter);
			this.boardLetterToImage[letter] = entry;
		}

		this.reset();
	}

	function emptyTray() {
		for (letter : this.current) {
			this.letters.add(letter);
		}
		this.current = "";
	}

	function revealAll() {
		revealedAny = false;
		this.flashWordSet = {};
		for (word : this.foundWordMap.keys()) {
			if (!this.foundWordMap[word]) {
				this.foundWordMap[word] = true;
				this.missedWordSet[word] = true;
				revealedAny = true;
			}
		}
		if (revealedAny) {
			this.flashColor = this.currentScore < floor(REQUIRED_SCORE_RATIO * this.maxScore)
				? TextColor.RED
				: TextColor.GREEN
				;
		}
		return revealedAny;
	}

	function update(inputManager, events) {
		// Reveal all or reset.
		if (inputManager.isKeyPressedThisFrame(KeyboardKey.ESCAPE)) {
			if (!this.revealAll()) {
				this.reset();
			}
		}

		// Shuffle letter tray.
		if (inputManager.isShiftPressed()) {
			this.letters.shuffle();
		}

		// Use letters.
		for (event : events) {
			if (event.type == EventType.KEY && event.down) {
				if (MainScene.keyToLetter.contains(event.key)) {
					letter = MainScene.keyToLetter[event.key];
					for (i = 0; i < this.letters.length; ++i) {
						if (this.letters[i] == letter) {
							this.current += this.letters[i];
							this.letters.remove(i);
							break;
						}
					}
				}
			}
		}

		// Return letters to tray.
		if (inputManager.isKeyPressedThisFrame(KeyboardKey.SPACE)) {
			this.emptyTray();
		}

		// Return one letter to tray.
		if (inputManager.isKeyPressedThisFrame(KeyboardKey.PERIOD)) {
			if (this.current.length > 0) {
				this.letters.add(this.current[-1]);
				this.current = this.current[:-1];
			}
		}

		// Try current guess.
		if (inputManager.isKeyPressedThisFrame(KeyboardKey.ENTER)) {
			this.flashTimer = FLASH_DURATION;
			this.flashWordSet = {};
			this.flashWordSet[this.current] = true;
			if (this.foundWordMap.contains(this.current)) {
				if (this.foundWordMap[this.current]) {
					// Already found this word.
					this.flashColor = TextColor.YELLOW;
				} else {
					// New word.
					this.currentScore += MainScene.getScore(this.current);
					this.flashColor = TextColor.GREEN;
					this.foundWordMap[this.current] = true;
				}
				this.emptyTray();
			} else {
				this.flashColor = TextColor.RED;
			}
		}

		if (this.flashTimer > 0) {
			--this.flashTimer;
		}
	}

	function drawWord(string, x, y, traySized) {
		if (this.missedWordSet.contains(string)) {
			color = this.flashColor;
		} else {
			color = this.flashTimer % 12 >= 6 && this.flashWordSet.contains(string)
				? this.flashColor
				: TextColor.BLACK
				;
		}
		for (letter : string) {
			image = traySized ? this.trayLetterToImage[letter][color] : this.boardLetterToImage[letter][color];
			image.draw(x, y);
			x += traySized ? TRAY_COL_WIDTH : BOARD_COL_WIDTH;
		}
	}

	function render() {
		Graphics2D.Draw.fill(255, 255, 255);

		// Draw available letters.
		this.drawWord(this.letters.join(""), SIDE_PADDING, 0, true);

		// Draw current guess.
		this.drawWord(this.current, SIDE_PADDING, 1.5 * ROW_HEIGHT, false);

		// Draw found and missing words.
		row = 0;
		col = 0;
		for (word : this.foundWordMap.keys()) {
			if (col + word.length >= N_COLS) {
				++row;
				col = 0;
			}
			this.drawWord
				( this.foundWordMap[word] ? word : "-" * word.length
				, col * BOARD_COL_WIDTH + SIDE_PADDING
				, row * ROW_HEIGHT + BOARD_TOP_PADDING
				, false
				);
			col += word.length + 1;
		}

		// Draw score bar.
		Graphics2D.Draw.rectangle
			( 0
			, Y_RES - SCORE_BAR_HEIGHT
			, X_RES
			, SCORE_BAR_HEIGHT
			, 0, 0, 0
			);
		if (this.currentScore >= REQUIRED_SCORE_RATIO * this.maxScore) {
			r = 0;
			g = 255;
		} else {
			r = 255;
			g = 0;
		}
		Graphics2D.Draw.rectangle
			( 1
			, Y_RES - SCORE_BAR_HEIGHT + 1
			, (X_RES - 2) * this.currentScore / this.maxScore
			, SCORE_BAR_HEIGHT - 2
			, r, g, 0
			);
		Graphics2D.Draw.line(X_RES / 4, Y_RES - SCORE_BAR_HEIGHT + 1, X_RES / 4, Y_RES - 1, 2, 0, 255, 0);
	}
}
